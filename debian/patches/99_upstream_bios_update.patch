Status: stolen-from-upstream

Index: b/bios/acpi-dsdt.dsl
===================================================================
--- a/bios/acpi-dsdt.dsl	2006-09-28 21:56:20.000000000 +0300
+++ b/bios/acpi-dsdt.dsl	2008-05-29 05:01:49.000000000 +0300
@@ -170,6 +170,17 @@ DefinitionBlock (
             /* PIIX PCI to ISA irq remapping */
             OperationRegion (P40C, PCI_Config, 0x60, 0x04)
 
+            /* Real-time clock */
+            Device (RTC)
+            {
+                Name (_HID, EisaId ("PNP0B00"))
+                Name (_CRS, ResourceTemplate ()
+                {
+                    IO (Decode16, 0x0070, 0x0070, 0x10, 0x02)
+                    IRQNoFlags () {8}
+                    IO (Decode16, 0x0072, 0x0072, 0x02, 0x06)
+                })
+            }
 
             /* Keyboard seems to be important for WinXP install */
             Device (KBD)
Index: b/bios/rombios32.c
===================================================================
--- a/bios/rombios32.c	2008-05-29 05:01:48.000000000 +0300
+++ b/bios/rombios32.c	2008-05-29 05:01:49.000000000 +0300
@@ -1,5 +1,5 @@
 /////////////////////////////////////////////////////////////////////////
-// $Id: rombios32.c,v 1.17 2007/12/09 15:37:27 vruppert Exp $
+// $Id: rombios32.c,v 1.28 2008/05/02 18:37:47 sshwarts Exp $
 /////////////////////////////////////////////////////////////////////////
 //
 //  32 bit Bochs BIOS init code
@@ -343,6 +343,9 @@ void bios_printf(int flags, const char *
     char buf[1024];
     const char *s;
 
+    if ((flags & BIOS_PRINTF_DEBHALT) == BIOS_PRINTF_DEBHALT)
+        outb(PANIC_PORT2, 0x00);
+
     va_start(ap, fmt);
     vsnprintf(buf, sizeof(buf), fmt, ap);
     s = buf;
@@ -376,9 +379,11 @@ void delay_ms(int n)
 }
 
 int smp_cpus;
+uint32_t cpuid_signature;
 uint32_t cpuid_features;
 uint32_t cpuid_ext_features;
 unsigned long ram_size;
+uint8_t bios_uuid[16];
 #ifdef BX_USE_EBDA_TABLES
 unsigned long ebda_cur_addr;
 #endif
@@ -388,10 +393,38 @@ int pm_sci_int;
 unsigned long bios_table_cur_addr;
 unsigned long bios_table_end_addr;
 
+void uuid_probe(void)
+{
+#ifdef BX_QEMU
+    uint32_t eax, ebx, ecx, edx;
+
+    // check if backdoor port exists
+    asm volatile ("outl %%eax, %%dx"
+        : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
+        : "a" (0x564d5868), "c" (0xa), "d" (0x5658));
+    if (ebx == 0x564d5868) {
+        uint32_t *uuid_ptr = (uint32_t *)bios_uuid;
+        // get uuid
+        asm volatile ("outl %%eax, %%dx"
+            : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
+            : "a" (0x564d5868), "c" (0x13), "d" (0x5658));
+        uuid_ptr[0] = eax;
+        uuid_ptr[1] = ebx;
+        uuid_ptr[2] = ecx;
+        uuid_ptr[3] = edx;
+    } else
+#endif
+    {
+        // UUID not set
+        memset(bios_uuid, 0, 16);
+    }
+}
+
 void cpu_probe(void)
 {
     uint32_t eax, ebx, ecx, edx;
     cpuid(1, eax, ebx, ecx, edx);
+    cpuid_signature = eax;
     cpuid_features = edx;
     cpuid_ext_features = ecx;
 }
@@ -408,11 +441,13 @@ void ram_probe(void)
     ram_size = (cmos_readb(0x34) | (cmos_readb(0x35) << 8)) * 65536 + 
         16 * 1024 * 1024;
   else
-    ram_size = (cmos_readb(0x17) | (cmos_readb(0x18) << 8)) * 1024;
+    ram_size = (cmos_readb(0x30) | (cmos_readb(0x31) << 8)) * 1024 +
+        1 * 1024 * 1024;
+  BX_INFO("ram_size=0x%08lx\n", ram_size);
 #ifdef BX_USE_EBDA_TABLES
     ebda_cur_addr = ((*(uint16_t *)(0x40e)) << 4) + 0x380;
+  BX_INFO("ebda_cur_addr: 0x%08lx\n", ebda_cur_addr);
 #endif
-    BX_INFO("ram_size=0x%08lx\n", ram_size);
 }
 
 /****************************************************/
@@ -474,6 +509,15 @@ void smp_probe(void)
 #define PCI_MIN_GNT		0x3e	/* 8 bits */
 #define PCI_MAX_LAT		0x3f	/* 8 bits */
 
+#define PCI_VENDOR_ID_INTEL             0x8086
+#define PCI_DEVICE_ID_INTEL_82441       0x1237
+#define PCI_DEVICE_ID_INTEL_82371SB_0   0x7000
+#define PCI_DEVICE_ID_INTEL_82371SB_1   0x7010
+#define PCI_DEVICE_ID_INTEL_82371AB_3   0x7113
+
+#define PCI_VENDOR_ID_IBM               0x1014
+#define PCI_VENDOR_ID_APPLE             0x106b
+
 typedef struct PCIDevice {
     int bus;
     int devfn;
@@ -612,7 +656,7 @@ static void pci_bios_init_bridges(PCIDev
     vendor_id = pci_config_readw(d, PCI_VENDOR_ID);
     device_id = pci_config_readw(d, PCI_DEVICE_ID);
     
-    if (vendor_id == 0x8086 && device_id == 0x7000) {
+    if (vendor_id == PCI_VENDOR_ID_INTEL && device_id == PCI_DEVICE_ID_INTEL_82371SB_0) {
         int i, irq;
         uint8_t elcr[2];
 
@@ -631,7 +675,7 @@ static void pci_bios_init_bridges(PCIDev
         outb(0x4d1, elcr[1]);
         BX_INFO("PIIX3 init: elcr=%02x %02x\n",
                 elcr[0], elcr[1]);
-    } else if (vendor_id == 0x8086 && device_id == 0x1237) {
+    } else if (vendor_id == PCI_VENDOR_ID_INTEL && device_id == PCI_DEVICE_ID_INTEL_82441) {
         /* i440 PCI bridge */
         bios_shadow_init(d);        
     }
@@ -692,7 +736,7 @@ static void pci_bios_init_device(PCIDevi
             d->bus, d->devfn, vendor_id, device_id);
     switch(class) {
     case 0x0101:
-        if (vendor_id == 0x8086 && device_id == 0x7010) {
+        if (vendor_id == PCI_VENDOR_ID_INTEL && device_id == PCI_DEVICE_ID_INTEL_82371SB_1) {
             /* PIIX3 IDE */
             pci_config_writew(d, 0x40, 0x8000); // enable IDE0
             pci_config_writew(d, 0x42, 0x8000); // enable IDE1
@@ -713,7 +757,7 @@ static void pci_bios_init_device(PCIDevi
         break;
     case 0x0800:
         /* PIC */
-        if (vendor_id == 0x1014) {
+        if (vendor_id == PCI_VENDOR_ID_IBM) {
             /* IBM */
             if (device_id == 0x0046 || device_id == 0xFFFF) {
                 /* MPIC & MPIC2 */
@@ -722,7 +766,7 @@ static void pci_bios_init_device(PCIDevi
         }
         break;
     case 0xff00:
-        if (vendor_id == 0x0106b &&
+        if (vendor_id == PCI_VENDOR_ID_APPLE &&
             (device_id == 0x0017 || device_id == 0x0022)) {
             /* macio bridge */
             pci_set_io_region_addr(d, 0, 0x80800000);
@@ -765,7 +809,7 @@ static void pci_bios_init_device(PCIDevi
         pci_config_writeb(d, PCI_INTERRUPT_LINE, pic_irq);
     }
 
-    if (vendor_id == 0x8086 && device_id == 0x7113) {
+    if (vendor_id == PCI_VENDOR_ID_INTEL && device_id == PCI_DEVICE_ID_INTEL_82371AB_3) {
         /* PIIX4 Power Management device (for ACPI) */
         pm_io_base = PM_IO_BASE;
         pci_config_writel(d, 0x40, pm_io_base | 1);
@@ -873,6 +917,11 @@ static void mptable_init(void)
     int ioapic_id, i, len;
     int mp_config_table_size;
 
+#ifdef BX_QEMU
+    if (smp_cpus <= 1)
+        return;
+#endif
+
 #ifdef BX_USE_EBDA_TABLES
     mp_config_table = (uint8_t *)(ram_size - ACPI_DATA_SIZE - MPTABLE_MAX_SIZE);
 #else
@@ -1033,7 +1082,7 @@ struct rsdp_descriptor         /* Root S
 struct rsdt_descriptor_rev1
 {
 	ACPI_TABLE_HEADER_DEF                           /* ACPI common table header */
-	uint32_t                             table_offset_entry [2]; /* Array of pointers to other */
+	uint32_t                             table_offset_entry [3]; /* Array of pointers to other */
 			 /* ACPI tables */
 };
 
@@ -1228,6 +1277,57 @@ static void acpi_build_table_header(stru
     h->checksum = acpi_checksum((void *)h, len);
 }
 
+int acpi_build_processor_ssdt(uint8_t *ssdt)
+{
+    uint8_t *ssdt_ptr = ssdt;
+    int i, length;
+    int acpi_cpus = smp_cpus > 0xff ? 0xff : smp_cpus;
+
+    ssdt_ptr[9] = 0; // checksum;
+    ssdt_ptr += sizeof(struct acpi_table_header);
+
+    // caluculate the length of processor block and scope block excluding PkgLength
+    length = 0x0d * acpi_cpus + 4;
+
+    // build processor scope header
+    *(ssdt_ptr++) = 0x10; // ScopeOp
+    if (length <= 0x3e) {
+        *(ssdt_ptr++) = length + 1;
+    } else {
+        *(ssdt_ptr++) = 0x7F;
+        *(ssdt_ptr++) = (length + 2) >> 6;
+    }
+    *(ssdt_ptr++) = '_'; // Name
+    *(ssdt_ptr++) = 'P';
+    *(ssdt_ptr++) = 'R';
+    *(ssdt_ptr++) = '_';
+
+    // build object for each processor
+    for(i=0;i<acpi_cpus;i++) {
+        *(ssdt_ptr++) = 0x5B; // ProcessorOp
+        *(ssdt_ptr++) = 0x83;
+        *(ssdt_ptr++) = 0x0B; // Length
+        *(ssdt_ptr++) = 'C';  // Name (CPUxx)
+        *(ssdt_ptr++) = 'P';
+        if ((i & 0xf0) != 0)
+            *(ssdt_ptr++) = (i >> 4) < 0xa ? (i >> 4) + '0' : (i >> 4) + 'A' - 0xa;
+        else
+            *(ssdt_ptr++) = 'U';
+        *(ssdt_ptr++) = (i & 0xf) < 0xa ? (i & 0xf) + '0' : (i & 0xf) + 'A' - 0xa;
+        *(ssdt_ptr++) = i;
+        *(ssdt_ptr++) = 0x10; // Processor block address
+        *(ssdt_ptr++) = 0xb0;
+        *(ssdt_ptr++) = 0;
+        *(ssdt_ptr++) = 0;
+        *(ssdt_ptr++) = 6;    // Processor block length
+    }
+
+    acpi_build_table_header((struct acpi_table_header *)ssdt,
+                            "SSDT", ssdt_ptr - ssdt, 1);
+
+    return ssdt_ptr - ssdt;
+}
+
 /* base_addr must be a multiple of 4KB */
 void acpi_bios_init(void)
 {
@@ -1236,8 +1336,8 @@ void acpi_bios_init(void)
     struct fadt_descriptor_rev1 *fadt;
     struct facs_descriptor_rev1 *facs;
     struct multiple_apic_table *madt;
-    uint8_t *dsdt;
-    uint32_t base_addr, rsdt_addr, fadt_addr, addr, facs_addr, dsdt_addr;
+    uint8_t *dsdt, *ssdt;
+    uint32_t base_addr, rsdt_addr, fadt_addr, addr, facs_addr, dsdt_addr, ssdt_addr;
     uint32_t acpi_tables_size, madt_addr, madt_size;
     int i;
 
@@ -1271,6 +1371,10 @@ void acpi_bios_init(void)
     dsdt = (void *)(addr);
     addr += sizeof(AmlCode);
 
+    ssdt_addr = addr;
+    ssdt = (void *)(addr);
+    addr += acpi_build_processor_ssdt(ssdt);
+
     addr = (addr + 7) & ~7;
     madt_addr = addr;
     madt_size = sizeof(*madt) + 
@@ -1300,6 +1404,7 @@ void acpi_bios_init(void)
     memset(rsdt, 0, sizeof(*rsdt));
     rsdt->table_offset_entry[0] = cpu_to_le32(fadt_addr);
     rsdt->table_offset_entry[1] = cpu_to_le32(madt_addr);
+    rsdt->table_offset_entry[2] = cpu_to_le32(ssdt_addr);
     acpi_build_table_header((struct acpi_table_header *)rsdt, 
                             "RSDT", sizeof(*rsdt), 1);
     
@@ -1319,9 +1424,8 @@ void acpi_bios_init(void)
     fadt->pm1_evt_len = 4;
     fadt->pm1_cnt_len = 2;
     fadt->pm_tmr_len = 4;
-    fadt->plvl2_lat = cpu_to_le16(50);
-    fadt->plvl3_lat = cpu_to_le16(50);
-    fadt->plvl3_lat = cpu_to_le16(50);
+    fadt->plvl2_lat = cpu_to_le16(0xfff); // C2 state not supported
+    fadt->plvl3_lat = cpu_to_le16(0xfff); // C3 state not supported
     /* WBINVD + PROC_C1 + PWR_BUTTON + SLP_BUTTON + FIX_RTC */
     fadt->flags = cpu_to_le32((1 << 0) | (1 << 2) | (1 << 4) | (1 << 5) | (1 << 6));
     acpi_build_table_header((struct acpi_table_header *)fadt, "FACP", 
@@ -1364,6 +1468,516 @@ void acpi_bios_init(void)
     }
 }
 
+/* SMBIOS entry point -- must be written to a 16-bit aligned address
+   between 0xf0000 and 0xfffff.
+ */
+struct smbios_entry_point {
+	char anchor_string[4];
+	uint8_t checksum;
+	uint8_t length;
+	uint8_t smbios_major_version;
+	uint8_t smbios_minor_version;
+	uint16_t max_structure_size;
+	uint8_t entry_point_revision;
+	uint8_t formatted_area[5];
+	char intermediate_anchor_string[5];
+	uint8_t intermediate_checksum;
+	uint16_t structure_table_length;
+	uint32_t structure_table_address;
+	uint16_t number_of_structures;
+	uint8_t smbios_bcd_revision;
+} __attribute__((__packed__));
+
+/* This goes at the beginning of every SMBIOS structure. */
+struct smbios_structure_header {
+	uint8_t type;
+	uint8_t length;
+	uint16_t handle;
+} __attribute__((__packed__));
+
+/* SMBIOS type 0 - BIOS Information */
+struct smbios_type_0 {
+	struct smbios_structure_header header;
+	uint8_t vendor_str;
+	uint8_t bios_version_str;
+	uint16_t bios_starting_address_segment;
+	uint8_t bios_release_date_str;
+	uint8_t bios_rom_size;
+	uint8_t bios_characteristics[8];
+	uint8_t bios_characteristics_extension_bytes[2];
+	uint8_t system_bios_major_release;
+	uint8_t system_bios_minor_release;
+	uint8_t embedded_controller_major_release;
+	uint8_t embedded_controller_minor_release;
+} __attribute__((__packed__));
+
+/* SMBIOS type 1 - System Information */
+struct smbios_type_1 {
+	struct smbios_structure_header header;
+	uint8_t manufacturer_str;
+	uint8_t product_name_str;
+	uint8_t version_str;
+	uint8_t serial_number_str;
+	uint8_t uuid[16];
+	uint8_t wake_up_type;
+	uint8_t sku_number_str;
+	uint8_t family_str;
+} __attribute__((__packed__));
+
+/* SMBIOS type 3 - System Enclosure (v2.3) */
+struct smbios_type_3 {
+	struct smbios_structure_header header;
+	uint8_t manufacturer_str;
+	uint8_t type;
+	uint8_t version_str;
+	uint8_t serial_number_str;
+	uint8_t asset_tag_number_str;
+	uint8_t boot_up_state;
+	uint8_t power_supply_state;
+	uint8_t thermal_state;
+	uint8_t security_status;
+    uint32_t oem_defined;
+    uint8_t height;
+    uint8_t number_of_power_cords;
+    uint8_t contained_element_count;
+    // contained elements follow
+} __attribute__((__packed__));
+
+/* SMBIOS type 4 - Processor Information (v2.0) */
+struct smbios_type_4 {
+	struct smbios_structure_header header;
+	uint8_t socket_designation_str;
+	uint8_t processor_type;
+	uint8_t processor_family;
+	uint8_t processor_manufacturer_str;
+	uint32_t processor_id[2];
+	uint8_t processor_version_str;
+	uint8_t voltage;
+	uint16_t external_clock;
+	uint16_t max_speed;
+	uint16_t current_speed;
+	uint8_t status;
+	uint8_t processor_upgrade;
+} __attribute__((__packed__));
+
+/* SMBIOS type 16 - Physical Memory Array
+ *   Associated with one type 17 (Memory Device).
+ */
+struct smbios_type_16 {
+	struct smbios_structure_header header;
+	uint8_t location;
+	uint8_t use;
+	uint8_t error_correction;
+	uint32_t maximum_capacity;
+	uint16_t memory_error_information_handle;
+	uint16_t number_of_memory_devices;
+} __attribute__((__packed__));
+
+/* SMBIOS type 17 - Memory Device
+ *   Associated with one type 19
+ */
+struct smbios_type_17 {
+	struct smbios_structure_header header;
+	uint16_t physical_memory_array_handle;
+	uint16_t memory_error_information_handle;
+	uint16_t total_width;
+	uint16_t data_width;
+	uint16_t size;
+	uint8_t form_factor;
+	uint8_t device_set;
+	uint8_t device_locator_str;
+	uint8_t bank_locator_str;
+	uint8_t memory_type;
+	uint16_t type_detail;
+} __attribute__((__packed__));
+
+/* SMBIOS type 19 - Memory Array Mapped Address */
+struct smbios_type_19 {
+	struct smbios_structure_header header;
+	uint32_t starting_address;
+	uint32_t ending_address;
+	uint16_t memory_array_handle;
+	uint8_t partition_width;
+} __attribute__((__packed__));
+
+/* SMBIOS type 20 - Memory Device Mapped Address */
+struct smbios_type_20 {
+	struct smbios_structure_header header;
+	uint32_t starting_address;
+	uint32_t ending_address;
+	uint16_t memory_device_handle;
+	uint16_t memory_array_mapped_address_handle;
+	uint8_t partition_row_position;
+	uint8_t interleave_position;
+	uint8_t interleaved_data_depth;
+} __attribute__((__packed__));
+
+/* SMBIOS type 32 - System Boot Information */
+struct smbios_type_32 {
+	struct smbios_structure_header header;
+	uint8_t reserved[6];
+	uint8_t boot_status;
+} __attribute__((__packed__));
+
+/* SMBIOS type 127 -- End-of-table */
+struct smbios_type_127 {
+	struct smbios_structure_header header;
+} __attribute__((__packed__));
+
+static void
+smbios_entry_point_init(void *start,
+                        uint16_t max_structure_size,
+                        uint16_t structure_table_length,
+                        uint32_t structure_table_address,
+                        uint16_t number_of_structures)
+{
+    uint8_t sum;
+    int i;
+    struct smbios_entry_point *ep = (struct smbios_entry_point *)start;
+
+    memcpy(ep->anchor_string, "_SM_", 4);
+    ep->length = 0x1f;
+    ep->smbios_major_version = 2;
+    ep->smbios_minor_version = 4;
+    ep->max_structure_size = max_structure_size;
+    ep->entry_point_revision = 0;
+    memset(ep->formatted_area, 0, 5);
+    memcpy(ep->intermediate_anchor_string, "_DMI_", 5);
+
+    ep->structure_table_length = structure_table_length;
+    ep->structure_table_address = structure_table_address;
+    ep->number_of_structures = number_of_structures;
+    ep->smbios_bcd_revision = 0x24;
+
+    ep->checksum = 0;
+    ep->intermediate_checksum = 0;
+
+    sum = 0;
+    for (i = 0; i < 0x10; i++)
+        sum += ((int8_t *)start)[i];
+    ep->checksum = -sum;
+
+    sum = 0;
+    for (i = 0x10; i < ep->length; i++)
+        sum += ((int8_t *)start)[i];
+    ep->intermediate_checksum = -sum;
+    }
+
+/* Type 0 -- BIOS Information */
+#define RELEASE_DATE_STR "01/01/2007"
+static void *
+smbios_type_0_init(void *start)
+{
+    struct smbios_type_0 *p = (struct smbios_type_0 *)start;
+
+    p->header.type = 0;
+    p->header.length = sizeof(struct smbios_type_0);
+    p->header.handle = 0;
+
+    p->vendor_str = 1;
+    p->bios_version_str = 1;
+    p->bios_starting_address_segment = 0xe800;
+    p->bios_release_date_str = 2;
+    p->bios_rom_size = 0; /* FIXME */
+
+    memset(p->bios_characteristics, 0, 8);
+    p->bios_characteristics[0] = 0x08; /* BIOS characteristics not supported */
+    p->bios_characteristics_extension_bytes[0] = 0;
+    p->bios_characteristics_extension_bytes[1] = 0;
+
+    p->system_bios_major_release = 1;
+    p->system_bios_minor_release = 0;
+    p->embedded_controller_major_release = 0xff;
+    p->embedded_controller_minor_release = 0xff;
+
+    start += sizeof(struct smbios_type_0);
+    memcpy((char *)start, BX_APPNAME, sizeof(BX_APPNAME));
+    start += sizeof(BX_APPNAME);
+    memcpy((char *)start, RELEASE_DATE_STR, sizeof(RELEASE_DATE_STR));
+    start += sizeof(RELEASE_DATE_STR);
+    *((uint8_t *)start) = 0;
+
+    return start+1;
+}
+
+/* Type 1 -- System Information */
+static void *
+smbios_type_1_init(void *start)
+{
+    struct smbios_type_1 *p = (struct smbios_type_1 *)start;
+    p->header.type = 1;
+    p->header.length = sizeof(struct smbios_type_1);
+    p->header.handle = 0x100;
+
+    p->manufacturer_str = 0;
+    p->product_name_str = 0;
+    p->version_str = 0;
+    p->serial_number_str = 0;
+
+    memcpy(p->uuid, bios_uuid, 16);
+
+    p->wake_up_type = 0x06; /* power switch */
+    p->sku_number_str = 0;
+    p->family_str = 0;
+
+    start += sizeof(struct smbios_type_1);
+    *((uint16_t *)start) = 0;
+
+    return start+2;
+}
+
+/* Type 3 -- System Enclosure */
+static void *
+smbios_type_3_init(void *start)
+{
+    struct smbios_type_3 *p = (struct smbios_type_3 *)start;
+
+    p->header.type = 3;
+    p->header.length = sizeof(struct smbios_type_3);
+    p->header.handle = 0x300;
+
+    p->manufacturer_str = 0;
+    p->type = 0x01; /* other */
+    p->version_str = 0;
+    p->serial_number_str = 0;
+    p->asset_tag_number_str = 0;
+    p->boot_up_state = 0x03; /* safe */
+    p->power_supply_state = 0x03; /* safe */
+    p->thermal_state = 0x03; /* safe */
+    p->security_status = 0x02; /* unknown */
+    p->oem_defined = 0;
+    p->height = 0;
+    p->number_of_power_cords = 0;
+    p->contained_element_count = 0;
+
+    start += sizeof(struct smbios_type_3);
+    *((uint16_t *)start) = 0;
+
+    return start+2;
+}
+
+/* Type 4 -- Processor Information */
+static void *
+smbios_type_4_init(void *start, unsigned int cpu_number)
+{
+    struct smbios_type_4 *p = (struct smbios_type_4 *)start;
+
+    p->header.type = 4;
+    p->header.length = sizeof(struct smbios_type_4);
+    p->header.handle = 0x400 + cpu_number;
+
+    p->socket_designation_str = 1;
+    p->processor_type = 0x03; /* CPU */
+    p->processor_family = 0x01; /* other */
+    p->processor_manufacturer_str = 0;
+
+    p->processor_id[0] = cpuid_signature;
+    p->processor_id[1] = cpuid_features;
+
+    p->processor_version_str = 0;
+    p->voltage = 0;
+    p->external_clock = 0;
+
+    p->max_speed = 0; /* unknown */
+    p->current_speed = 0; /* unknown */
+
+    p->status = 0x41; /* socket populated, CPU enabled */
+    p->processor_upgrade = 0x01; /* other */
+
+    start += sizeof(struct smbios_type_4);
+
+    memcpy((char *)start, "CPU  " "\0" "" "\0" "", 7);
+	((char *)start)[4] = cpu_number + '0';
+
+    return start+7;
+}
+
+/* Type 16 -- Physical Memory Array */
+static void *
+smbios_type_16_init(void *start, uint32_t memsize)
+{
+    struct smbios_type_16 *p = (struct smbios_type_16*)start;
+
+    p->header.type = 16;
+    p->header.length = sizeof(struct smbios_type_16);
+    p->header.handle = 0x1000;
+
+    p->location = 0x01; /* other */
+    p->use = 0x03; /* system memory */
+    p->error_correction = 0x01; /* other */
+    p->maximum_capacity = memsize * 1024;
+    p->memory_error_information_handle = 0xfffe; /* none provided */
+    p->number_of_memory_devices = 1;
+
+    start += sizeof(struct smbios_type_16);
+    *((uint16_t *)start) = 0;
+
+    return start + 2;
+}
+
+/* Type 17 -- Memory Device */
+static void *
+smbios_type_17_init(void *start, uint32_t memory_size_mb)
+{
+    struct smbios_type_17 *p = (struct smbios_type_17 *)start;
+
+    p->header.type = 17;
+    p->header.length = sizeof(struct smbios_type_17);
+    p->header.handle = 0x1100;
+
+    p->physical_memory_array_handle = 0x1000;
+    p->total_width = 64;
+    p->data_width = 64;
+    /* truncate memory_size_mb to 16 bits and clear most significant
+       bit [indicates size in MB] */
+    p->size = (uint16_t) memory_size_mb & 0x7fff;
+    p->form_factor = 0x09; /* DIMM */
+    p->device_set = 0;
+    p->device_locator_str = 1;
+    p->bank_locator_str = 0;
+    p->memory_type = 0x07; /* RAM */
+    p->type_detail = 0;
+
+    start += sizeof(struct smbios_type_17);
+    memcpy((char *)start, "DIMM 1", 7);
+    start += 7;
+    *((uint8_t *)start) = 0;
+
+    return start+1;
+}
+
+/* Type 19 -- Memory Array Mapped Address */
+static void *
+smbios_type_19_init(void *start, uint32_t memory_size_mb)
+{
+    struct smbios_type_19 *p = (struct smbios_type_19 *)start;
+
+    p->header.type = 19;
+    p->header.length = sizeof(struct smbios_type_19);
+    p->header.handle = 0x1300;
+
+    p->starting_address = 0;
+    p->ending_address = (memory_size_mb-1) * 1024;
+    p->memory_array_handle = 0x1000;
+    p->partition_width = 1;
+
+    start += sizeof(struct smbios_type_19);
+    *((uint16_t *)start) = 0;
+
+    return start + 2;
+}
+
+/* Type 20 -- Memory Device Mapped Address */
+static void *
+smbios_type_20_init(void *start, uint32_t memory_size_mb)
+{
+    struct smbios_type_20 *p = (struct smbios_type_20 *)start;
+
+    p->header.type = 20;
+    p->header.length = sizeof(struct smbios_type_20);
+    p->header.handle = 0x1400;
+
+    p->starting_address = 0;
+    p->ending_address = (memory_size_mb-1)*1024;
+    p->memory_device_handle = 0x1100;
+    p->memory_array_mapped_address_handle = 0x1300;
+    p->partition_row_position = 1;
+    p->interleave_position = 0;
+    p->interleaved_data_depth = 0;
+
+    start += sizeof(struct smbios_type_20);
+
+    *((uint16_t *)start) = 0;
+    return start+2;
+}
+
+/* Type 32 -- System Boot Information */
+static void *
+smbios_type_32_init(void *start)
+{
+    struct smbios_type_32 *p = (struct smbios_type_32 *)start;
+
+    p->header.type = 32;
+    p->header.length = sizeof(struct smbios_type_32);
+    p->header.handle = 0x2000;
+    memset(p->reserved, 0, 6);
+    p->boot_status = 0; /* no errors detected */
+
+    start += sizeof(struct smbios_type_32);
+    *((uint16_t *)start) = 0;
+
+    return start+2;
+}
+
+/* Type 127 -- End of Table */
+static void *
+smbios_type_127_init(void *start)
+{
+    struct smbios_type_127 *p = (struct smbios_type_127 *)start;
+
+    p->header.type = 127;
+    p->header.length = sizeof(struct smbios_type_127);
+    p->header.handle = 0x7f00;
+
+    start += sizeof(struct smbios_type_127);
+    *((uint16_t *)start) = 0;
+
+    return start + 2;
+}
+
+void smbios_init(void)
+{
+    unsigned cpu_num, nr_structs = 0, max_struct_size = 0;
+    char *start, *p, *q;
+    int memsize = ram_size / (1024 * 1024);
+
+#ifdef BX_USE_EBDA_TABLES
+    ebda_cur_addr = align(ebda_cur_addr, 16);
+    start = (void *)(ebda_cur_addr);
+#else
+    bios_table_cur_addr = align(bios_table_cur_addr, 16);
+    start = (void *)(bios_table_cur_addr);
+#endif
+
+	p = (char *)start + sizeof(struct smbios_entry_point);
+
+#define add_struct(fn) { \
+    q = (fn); \
+    nr_structs++; \
+    if ((q - p) > max_struct_size) \
+        max_struct_size = q - p; \
+    p = q; \
+}
+
+    add_struct(smbios_type_0_init(p));
+    add_struct(smbios_type_1_init(p));
+    add_struct(smbios_type_3_init(p));
+    for (cpu_num = 1; cpu_num <= smp_cpus; cpu_num++)
+        add_struct(smbios_type_4_init(p, cpu_num));
+    add_struct(smbios_type_16_init(p, memsize));
+    add_struct(smbios_type_17_init(p, memsize));
+    add_struct(smbios_type_19_init(p, memsize));
+    add_struct(smbios_type_20_init(p, memsize));
+    add_struct(smbios_type_32_init(p));
+    add_struct(smbios_type_127_init(p));
+
+#undef add_struct
+
+    smbios_entry_point_init(
+        start, max_struct_size,
+        (p - (char *)start) - sizeof(struct smbios_entry_point),
+        (uint32_t)(start + sizeof(struct smbios_entry_point)),
+        nr_structs);
+
+#ifdef BX_USE_EBDA_TABLES
+    ebda_cur_addr += (p - (char *)start);
+#else
+    bios_table_cur_addr += (p - (char *)start);
+#endif
+
+    BX_INFO("SMBIOS table addr=0x%08lx\n", (unsigned long)start);
+}
+
 void rombios32_init(void)
 {
     BX_INFO("Starting rombios32\n");
@@ -1380,9 +1994,17 @@ void rombios32_init(void)
 
         mptable_init();
         
+        uuid_probe();
+
+        smbios_init();
+
         if (acpi_enabled)
             acpi_bios_init();
         
         bios_lock_shadow_ram();
+
+        BX_INFO("bios_table_cur_addr: 0x%08lx\n", bios_table_cur_addr);
+        if (bios_table_cur_addr > bios_table_end_addr)
+            BX_PANIC("bios_table_end_addr overflow!\n");
     }
 }
Index: b/bios/rombios32start.S
===================================================================
--- a/bios/rombios32start.S	2006-10-02 09:29:38.000000000 +0300
+++ b/bios/rombios32start.S	2008-05-29 05:01:49.000000000 +0300
@@ -1,5 +1,5 @@
 /////////////////////////////////////////////////////////////////////////
-// $Id: rombios32start.S,v 1.3 2006/10/02 06:29:38 vruppert Exp $
+// $Id: rombios32start.S,v 1.5 2008/03/28 09:02:57 sshwarts Exp $
 /////////////////////////////////////////////////////////////////////////
 //
 //  32 bit Bochs BIOS init code
@@ -42,7 +42,7 @@ _start:
 smp_ap_boot_code_start:
   xor %ax, %ax
   mov %ax, %ds
-  incw CPU_COUNT_ADDR
+  lock incw CPU_COUNT_ADDR
 1:
   hlt
   jmp 1b
Index: b/bios/rombios.c
===================================================================
--- a/bios/rombios.c	2007-12-23 21:46:27.000000000 +0200
+++ b/bios/rombios.c	2008-05-29 05:01:49.000000000 +0300
@@ -1,5 +1,5 @@
 /////////////////////////////////////////////////////////////////////////
-// $Id: rombios.c,v 1.194 2007/12/23 19:46:27 sshwarts Exp $
+// $Id: rombios.c,v 1.208 2008/05/18 11:37:57 vruppert Exp $
 /////////////////////////////////////////////////////////////////////////
 //
 //  Copyright (C) 2002  MandrakeSoft S.A.
@@ -175,21 +175,13 @@
 #define IPL_TABLE_ENTRIES    8
 #define IPL_COUNT_OFFSET     0x0080  /* u16: number of valid table entries */
 #define IPL_SEQUENCE_OFFSET  0x0082  /* u16: next boot device */
+#define IPL_BOOTFIRST_OFFSET 0x0084  /* u16: user selected device */
 #define IPL_SIZE             0xff
 #define IPL_TYPE_FLOPPY      0x01
 #define IPL_TYPE_HARDDISK    0x02
 #define IPL_TYPE_CDROM       0x03
 #define IPL_TYPE_BEV         0x80
 
-  // Define the application NAME
-#if defined(BX_QEMU)
-#  define BX_APPNAME "QEMU"
-#elif defined(PLEX86)
-#  define BX_APPNAME "Plex86"
-#else
-#  define BX_APPNAME "Bochs"
-#endif
-
   // Sanity Checks
 #if BX_USE_ATADRV && BX_CPU<3
 #    error The ATA/ATAPI Driver can only to be used with a 386+ cpu
@@ -674,7 +666,8 @@ typedef struct {
     chs_t  lchs;         // Logical CHS
     chs_t  pchs;         // Physical CHS
 
-    Bit32u sectors;      // Total sectors count
+    Bit32u sectors_low;  // Total sectors count
+    Bit32u sectors_high;
     } ata_device_t;
 
   typedef struct {
@@ -721,8 +714,8 @@ typedef struct {
   //     The EBDA structure should conform to
   //     http://www.frontiernet.net/~fys/rombios.htm document
   //     I made the ata and cdemu structs begin at 0x121 in the EBDA seg
-  // EBDA must be at most 768 bytes; it lives at 0x9fc00, and the boot
-  // device tables are at 0x9ff00 -- 0x9ffff
+  // EBDA must be at most 768 bytes; it lives at EBDA_SEG, and the boot
+  // device tables are at IPL_SEG
   typedef struct {
     unsigned char filler1[0x3D];
 
@@ -910,7 +903,10 @@ static void           keyboard_init();
 static void           keyboard_panic();
 static void           shutdown_status_panic();
 static void           nmi_handler_msg();
+static void           delay_ticks();
+static void           delay_ticks_and_check_for_keystroke();
 
+static void           interactive_bootkey();
 static void           print_bios_banner();
 static void           print_boot_device();
 static void           print_boot_failure();
@@ -944,7 +940,7 @@ Bit16u cdrom_boot();
 
 #endif // BX_ELTORITO_BOOT
 
-static char bios_cvs_version_string[] = "$Revision: 1.194 $ $Date: 2007/12/23 19:46:27 $";
+static char bios_cvs_version_string[] = "$Revision: 1.208 $ $Date: 2008/05/18 11:37:57 $";
 
 #define BIOS_COPYRIGHT_STRING "(c) 2002 MandrakeSoft S.A. Written by Kevin Lawton & the Bochs team."
 
@@ -1524,17 +1520,94 @@ put_luint(action, val, width, neg)
   send(action, val - (nval * 10) + '0');
 }
 
-void put_str(action, s)
+void put_str(action, segment, offset)
   Bit16u action;
-  Bit8u *s;
+  Bit16u segment;
+  Bit16u offset;
 {
   Bit8u c;
-  if (!s)
-    s = "<NULL>";
 
-  while (c = read_byte(get_CS(), s)) {
+  while (c = read_byte(segment, offset)) {
     send(action, c);
-    s++;
+    offset++;
+  }
+}
+
+  void
+delay_ticks(ticks)
+  Bit16u ticks;
+{
+  long ticks_to_wait, delta;
+  Bit32u prev_ticks, t;
+
+   /*
+    * The 0:046c wraps around at 'midnight' according to a 18.2Hz clock.
+    * We also have to be careful about interrupt storms.
+    */
+ASM_START
+  pushf
+  sti
+ASM_END
+  ticks_to_wait = ticks;
+  prev_ticks = read_dword(0x0, 0x46c);
+  do
+  {
+ASM_START
+    hlt
+ASM_END
+    t = read_dword(0x0, 0x46c);
+    if (t > prev_ticks)
+    {
+      delta = t - prev_ticks;     /* The temp var is required or bcc screws up. */
+      ticks_to_wait -= delta;
+    }
+    else if (t < prev_ticks)
+    {
+      ticks_to_wait -= t;         /* wrapped */
+    }
+
+    prev_ticks = t;
+  } while (ticks_to_wait > 0);
+ASM_START
+  cli
+  popf
+ASM_END
+}
+
+  Bit8u
+check_for_keystroke()
+{
+ASM_START
+  mov  ax, #0x100
+  int  #0x16
+  jz   no_key
+  mov  al, #1
+  jmp  done
+no_key:
+  xor  al, al
+done:
+ASM_END
+}
+
+  Bit8u
+get_keystroke()
+{
+ASM_START
+  mov  ax, #0x0
+  int  #0x16
+  xchg ah, al
+ASM_END
+}
+
+  void
+delay_ticks_and_check_for_keystroke(ticks, count)
+  Bit16u ticks, count;
+{
+  Bit16u i;
+  for (i = 1; i <= count; i++) {
+    delay_ticks(ticks);
+    if (check_for_keystroke())
+      break;
   }
 }
 
@@ -1543,7 +1616,7 @@ void put_str(action, s)
 //   A compact variable argument printf function.
 //
 //   Supports %[format_width][length]format
-//   where format can be x,X,u,d,s,c
+//   where format can be x,X,u,d,s,S,c
 //   and the optional length modifier is l (ell)
 //--------------------------------------------------------------------------
   void
@@ -1632,7 +1705,13 @@ bios_printf(action, s)
             put_int(action, arg, format_width, 0);
           }
         else if (c == 's') {
-          put_str(action, arg);
+          put_str(action, get_CS(), arg);
+          }
+        else if (c == 'S') {
+          hibyte = arg;
+          arg_ptr++;
+          arg = read_word(arg_seg, arg_ptr);
+          put_str(action, hibyte, arg);
           }
         else if (c == 'c') {
           send(action, arg);
@@ -1878,6 +1957,7 @@ print_bios_banner()
 // http://www.phoenix.com/en/Customer+Services/White+Papers-Specs/pc+industry+specifications.htm
 //--------------------------------------------------------------------------
 
+static char drivetypes[][10]={"", "Floppy","Hard Disk","CD-Rom", "Network"};
 
 static void
 init_boot_vectors() 
@@ -1889,6 +1969,9 @@ init_boot_vectors() 
   /* Clear out the IPL table. */
   memsetb(IPL_SEG, IPL_TABLE_OFFSET, 0, IPL_SIZE);
 
+  /* User selected device not set */
+  write_word(IPL_SEG, IPL_BOOTFIRST_OFFSET, 0xFFFF);
+
   /* Floppy drive */
   e.type = IPL_TYPE_FLOPPY; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
   memcpyb(IPL_SEG, IPL_TABLE_OFFSET + count * sizeof (e), ss, &e, sizeof (e));
@@ -1926,22 +2009,106 @@ Bit16u i; ipl_entry_t *e;
   return 1;
 }
 
+#if BX_ELTORITO_BOOT
+  void
+interactive_bootkey()
+{
+  ipl_entry_t e;
+  Bit16u count;
+  char description[33];
+  Bit8u scan_code;
+  Bit8u i;
+  Bit16u ss = get_SS();
+  Bit16u valid_choice = 0;
+
+  while (check_for_keystroke())
+    get_keystroke();
+
+  printf("Press F12 for boot menu.\n\n");
+
+  delay_ticks_and_check_for_keystroke(11, 5); /* ~3 seconds */
+  if (check_for_keystroke())
+  {
+    scan_code = get_keystroke();
+    if (scan_code == 0x58) /* F12 */
+    {
+      while (check_for_keystroke())
+        get_keystroke();
+
+      printf("Select boot device:\n\n");
+
+      count = read_word(IPL_SEG, IPL_COUNT_OFFSET);
+      for (i = 0; i < count; i++)
+      {
+        memcpyb(ss, &e, IPL_SEG, IPL_TABLE_OFFSET + i * sizeof (e), sizeof (e));
+        printf("%d. ", i+1);
+        switch(e.type)
+        {
+          case IPL_TYPE_FLOPPY:
+          case IPL_TYPE_HARDDISK:
+          case IPL_TYPE_CDROM:
+            printf("%s\n", drivetypes[e.type]);
+            break;
+          case IPL_TYPE_BEV:
+            printf("%s", drivetypes[4]);
+            if (e.description != 0)
+            {
+              memcpyb(ss, &description, (Bit16u)(e.description >> 16), (Bit16u)(e.description & 0xffff), 32);
+              description[32] = 0;
+              printf(" [%S]", ss, description);
+           }
+           printf("\n");
+           break;
+        }
+      }
+
+      count++;
+      while (!valid_choice) {
+        scan_code = get_keystroke();
+        if (scan_code == 0x01 || scan_code == 0x58) /* ESC or F12 */
+        {
+          valid_choice = 1;
+        }
+        else if (scan_code <= count)
+        {
+          valid_choice = 1;
+          scan_code -= 1;
+          /* Set user selected device */
+          write_word(IPL_SEG, IPL_BOOTFIRST_OFFSET, scan_code);
+        }
+      }
+    printf("\n");
+    }
+  }
+}
+#endif // BX_ELTORITO_BOOT
 
 //--------------------------------------------------------------------------
 // print_boot_device
 //   displays the boot device
 //--------------------------------------------------------------------------
 
-static char drivetypes[][10]={"", "Floppy","Hard Disk","CD-Rom", "Network"};
-
 void
-print_boot_device(type)
-  Bit16u type;
+print_boot_device(e)
+  ipl_entry_t *e;
 {
+  Bit16u type;
+  char description[33];
+  Bit16u ss = get_SS();
+  type = e->type;
   /* NIC appears as type 0x80 */
   if (type == IPL_TYPE_BEV) type = 0x4;
   if (type == 0 || type > 0x4) BX_PANIC("Bad drive type\n"); 
-  printf("Booting from %s...\n", drivetypes[type]);
+  printf("Booting from %s", drivetypes[type]);
+  /* print product string if BEV */
+  if (type == 4 && e->description != 0) {
+    /* first 32 bytes are significant */
+    memcpyb(ss, &description, (Bit16u)(e->description >> 16), (Bit16u)(e->description & 0xffff), 32);
+    /* terminate string */
+    description[32] = 0;
+    printf(" [%S]", ss, description);
+  }
+  printf("...\n");
 }
 
 //--------------------------------------------------------------------------
@@ -1954,7 +2121,7 @@ print_boot_failure(type, reason)
 {
   if (type == 0 || type > 0x3) BX_PANIC("Bad drive type\n");
 
-  printf("Boot from %s failed", drivetypes[type]);
+  printf("Boot failed");
   if (type < 4) {
     /* Report the reason too */
   if (reason==0)
@@ -1962,7 +2129,7 @@ print_boot_failure(type, reason)
   else
     printf(": could not read the boot disk");
   }
-  printf("\n");
+  printf("\n\n");
 }
 
 //--------------------------------------------------------------------------
@@ -2206,7 +2373,8 @@ void ata_init( )
     write_word(ebda_seg,&EbdaData->ata.devices[device].pchs.cylinders,0);
     write_word(ebda_seg,&EbdaData->ata.devices[device].pchs.spt,0);
 
-    write_dword(ebda_seg,&EbdaData->ata.devices[device].sectors,0L);
+    write_dword(ebda_seg,&EbdaData->ata.devices[device].sectors_low,0L);
+    write_dword(ebda_seg,&EbdaData->ata.devices[device].sectors_high,0L);
     }
 
   // hdidmap  and cdidmap init.
@@ -2368,7 +2536,7 @@ void ata_detect( )
 
     // Now we send a IDENTIFY command to ATA device
     if(type == ATA_TYPE_ATA) {
-      Bit32u sectors;
+      Bit32u sectors_low, sectors_high;
       Bit16u cylinders, heads, spt, blksize;
       Bit8u  translation, removable, mode;
 
@@ -2376,7 +2544,7 @@ void ata_detect( )
       write_byte(ebda_seg,&EbdaData->ata.devices[device].device,ATA_DEVICE_HD);
       write_byte(ebda_seg,&EbdaData->ata.devices[device].mode, ATA_MODE_PIO16);
 
-      if (ata_cmd_data_in(device,ATA_CMD_IDENTIFY_DEVICE, 1, 0, 0, 0, 0L, get_SS(),buffer) !=0 )
+      if (ata_cmd_data_in(device,ATA_CMD_IDENTIFY_DEVICE, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) !=0 )
         BX_PANIC("ata-detect: Failed to detect ATA device\n");
 
       removable = (read_byte(get_SS(),buffer+0) & 0x80) ? 1 : 0;
@@ -2387,7 +2555,13 @@ void ata_detect( )
       heads     = read_word(get_SS(),buffer+(3*2)); // word 3
       spt       = read_word(get_SS(),buffer+(6*2)); // word 6
 
-      sectors   = read_dword(get_SS(),buffer+(60*2)); // word 60 and word 61
+      if (read_word(get_SS(),buffer+(83*2)) & (1 << 10)) { // word 83 - lba48 support
+        sectors_low  = read_dword(get_SS(),buffer+(100*2)); // word 100 and word 101
+        sectors_high = read_dword(get_SS(),buffer+(102*2)); // word 102 and word 103
+      } else {
+        sectors_low = read_dword(get_SS(),buffer+(60*2)); // word 60 and word 61
+        sectors_high = 0;
+      }
 
       write_byte(ebda_seg,&EbdaData->ata.devices[device].device,ATA_DEVICE_HD);
       write_byte(ebda_seg,&EbdaData->ata.devices[device].removable, removable);
@@ -2396,7 +2570,8 @@ void ata_detect( )
       write_word(ebda_seg,&EbdaData->ata.devices[device].pchs.heads, heads);
       write_word(ebda_seg,&EbdaData->ata.devices[device].pchs.cylinders, cylinders);
       write_word(ebda_seg,&EbdaData->ata.devices[device].pchs.spt, spt);
-      write_dword(ebda_seg,&EbdaData->ata.devices[device].sectors, sectors);
+      write_dword(ebda_seg,&EbdaData->ata.devices[device].sectors_low, sectors_low);
+      write_dword(ebda_seg,&EbdaData->ata.devices[device].sectors_high, sectors_high);
       BX_INFO("ata%d-%d: PCHS=%u/%d/%d translation=", channel, slave,cylinders, heads, spt);
 
       translation = inb_cmos(0x39 + channel/2);
@@ -2424,14 +2599,14 @@ void ata_detect( )
           break;
         case ATA_TRANSLATION_LBA:
           spt = 63;
-          sectors /= 63;
-          heads = sectors / 1024;
+          sectors_low /= 63;
+          heads = sectors_low / 1024;
           if (heads>128) heads = 255;
           else if (heads>64) heads = 128;
           else if (heads>32) heads = 64;
           else if (heads>16) heads = 32;
           else heads=16;
-          cylinders = sectors / heads;
+          cylinders = sectors_low / heads;
           break;
         case ATA_TRANSLATION_RECHS:
           // Take care not to overflow
@@ -2474,7 +2649,7 @@ void ata_detect( )
       write_byte(ebda_seg,&EbdaData->ata.devices[device].device,ATA_DEVICE_CDROM);
       write_byte(ebda_seg,&EbdaData->ata.devices[device].mode, ATA_MODE_PIO16);
 
-      if (ata_cmd_data_in(device,ATA_CMD_IDENTIFY_DEVICE_PACKET, 1, 0, 0, 0, 0L, get_SS(),buffer) != 0)
+      if (ata_cmd_data_in(device,ATA_CMD_IDENTIFY_DEVICE_PACKET, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) != 0)
         BX_PANIC("ata-detect: Failed to detect ATAPI device\n");
 
       type      = read_byte(get_SS(),buffer+1) & 0x1f;
@@ -2499,8 +2674,8 @@ void ata_detect( )
 
       switch (type) {
         case ATA_TYPE_ATA:
-          sizeinmb = read_dword(ebda_seg,&EbdaData->ata.devices[device].sectors);
-          sizeinmb >>= 11;
+          sizeinmb = (read_dword(ebda_seg,&EbdaData->ata.devices[device].sectors_high) << 21)
+            | (read_dword(ebda_seg,&EbdaData->ata.devices[device].sectors_low) >> 11);
         case ATA_TYPE_ATAPI:
           // Read ATA/ATAPI version
           ataversion=((Bit16u)(read_byte(get_SS(),buffer+161))<<8)|read_byte(get_SS(),buffer+160);
@@ -2637,9 +2812,9 @@ Bit16u ata_cmd_non_data()
       // 5 : more sectors to read/verify
       // 6 : no sectors left to write
       // 7 : more sectors to write
-Bit16u ata_cmd_data_in(device, command, count, cylinder, head, sector, lba, segment, offset)
+Bit16u ata_cmd_data_in(device, command, count, cylinder, head, sector, lba_low, lba_high, segment, offset)
 Bit16u device, command, count, cylinder, head, sector, segment, offset;
-Bit32u lba;
+Bit32u lba_low, lba_high;
 {
   Bit16u ebda_seg=read_word(0x0040,0x000E);
   Bit16u iobase1, iobase2, blksize;
@@ -2656,14 +2831,6 @@ Bit32u lba;
   if (mode == ATA_MODE_PIO32) blksize>>=2;
   else blksize>>=1;
 
-  //!!FIXME!! this only works up to 28-bit LBA
-  // sector will be 0 only on lba access. Convert to lba-chs
-  if (sector == 0) {
-    sector = (Bit16u) (lba & 0x000000ffL);
-    cylinder = (Bit16u) ((lba>>8) & 0x0000ffffL);
-    head = ((Bit16u) ((lba>>24) & 0x0000000fL)) | ATA_CB_DH_LBA;
-  }
-
   // Reset count of transferred data
   write_word(ebda_seg, &EbdaData->ata.trsfsectors,0);
   write_dword(ebda_seg, &EbdaData->ata.trsfbytes,0L);
@@ -2673,6 +2840,24 @@ Bit32u lba;
   if (status & ATA_CB_STAT_BSY) return 1;
 
   outb(iobase2 + ATA_CB_DC, ATA_CB_DC_HD15 | ATA_CB_DC_NIEN);
+
+  // sector will be 0 only on lba access. Convert to lba-chs
+  if (sector == 0) {
+    if ((count >= 1 << 8) || lba_high || (lba_low + count >= 1UL << 28)) {
+      outb(iobase1 + ATA_CB_FR, 0x00);
+      outb(iobase1 + ATA_CB_SC, (count >> 8) & 0xff);
+      outb(iobase1 + ATA_CB_SN, lba_low >> 24);
+      outb(iobase1 + ATA_CB_CL, lba_high & 0xff);
+      outb(iobase1 + ATA_CB_CH, lba_high >> 8);
+      command |= 0x04;
+      count &= (1UL << 8) - 1;
+      lba_low &= (1UL << 24) - 1;
+      }
+    sector = (Bit16u) (lba_low & 0x000000ffL);
+    cylinder = (Bit16u) ((lba_low>>8) & 0x0000ffffL);
+    head = ((Bit16u) ((lba_low>>24) & 0x0000000fL)) | ATA_CB_DH_LBA;
+  }
+
   outb(iobase1 + ATA_CB_FR, 0x00);
   outb(iobase1 + ATA_CB_SC, count);
   outb(iobase1 + ATA_CB_SN, sector);
@@ -2778,9 +2963,9 @@ ASM_END
       // 5 : more sectors to read/verify
       // 6 : no sectors left to write
       // 7 : more sectors to write
-Bit16u ata_cmd_data_out(device, command, count, cylinder, head, sector, lba, segment, offset)
+Bit16u ata_cmd_data_out(device, command, count, cylinder, head, sector, lba_low, lba_high, segment, offset)
 Bit16u device, command, count, cylinder, head, sector, segment, offset;
-Bit32u lba;
+Bit32u lba_low, lba_high;
 {
   Bit16u ebda_seg=read_word(0x0040,0x000E);
   Bit16u iobase1, iobase2, blksize;
@@ -2797,14 +2982,6 @@ Bit32u lba;
   if (mode == ATA_MODE_PIO32) blksize>>=2;
   else blksize>>=1;
 
-  //!!FIXME!! this only works up to 28-bit LBA
-  // sector will be 0 only on lba access. Convert to lba-chs
-  if (sector == 0) {
-    sector = (Bit16u) (lba & 0x000000ffL);
-    cylinder = (Bit16u) ((lba>>8) & 0x0000ffffL);
-    head = ((Bit16u) ((lba>>24) & 0x0000000fL)) | ATA_CB_DH_LBA;
-  }
-
   // Reset count of transferred data
   write_word(ebda_seg, &EbdaData->ata.trsfsectors,0);
   write_dword(ebda_seg, &EbdaData->ata.trsfbytes,0L);
@@ -2814,6 +2991,24 @@ Bit32u lba;
   if (status & ATA_CB_STAT_BSY) return 1;
 
   outb(iobase2 + ATA_CB_DC, ATA_CB_DC_HD15 | ATA_CB_DC_NIEN);
+
+  // sector will be 0 only on lba access. Convert to lba-chs
+  if (sector == 0) {
+    if ((count >= 1 << 8) || lba_high || (lba_low + count >= 1UL << 28)) {
+      outb(iobase1 + ATA_CB_FR, 0x00);
+      outb(iobase1 + ATA_CB_SC, (count >> 8) & 0xff);
+      outb(iobase1 + ATA_CB_SN, lba_low >> 24);
+      outb(iobase1 + ATA_CB_CL, lba_high & 0xff);
+      outb(iobase1 + ATA_CB_CH, lba_high >> 8);
+      command |= 0x04;
+      count &= (1UL << 8) - 1;
+      lba_low &= (1UL << 24) - 1;
+      }
+    sector = (Bit16u) (lba_low & 0x000000ffL);
+    cylinder = (Bit16u) ((lba_low>>8) & 0x0000ffffL);
+    head = ((Bit16u) ((lba_low>>24) & 0x0000000fL)) | ATA_CB_DH_LBA;
+  }
+
   outb(iobase1 + ATA_CB_FR, 0x00);
   outb(iobase1 + ATA_CB_SC, count);
   outb(iobase1 + ATA_CB_SN, sector);
@@ -3288,9 +3483,9 @@ ok:
   BX_DEBUG_ATA("sectors=%u\n", sectors);
   if (block_len == 2048)
     sectors <<= 2; /* # of sectors in 512-byte "soft" sector */
-  if (sectors != read_dword(ebda_seg,&EbdaData->ata.devices[device].sectors))
+  if (sectors != read_dword(ebda_seg,&EbdaData->ata.devices[device].sectors_low))
     printf("%dMB medium detected\n", sectors>>(20-9));
-  write_dword(ebda_seg,&EbdaData->ata.devices[device].sectors, sectors);
+  write_dword(ebda_seg,&EbdaData->ata.devices[device].sectors_low, sectors);
   return 0;
 }
 
@@ -4206,7 +4401,7 @@ BX_DEBUG_INT15("case default:\n");
       break;
     }
 }
-#endif
+#endif // BX_USE_PS2_MOUSE
 
 
 void set_e820_range(ES, DI, start, end, type)
@@ -4308,6 +4503,7 @@ ASM_END
                     extended_memory_size <<= 8;
                     extended_memory_size |= inb_cmos(0x30);
                     extended_memory_size *= 1024;
+                    extended_memory_size += (1L * 1024 * 1024);
                 }
 
                 switch(regs.u.r16.bx)
@@ -4340,10 +4536,17 @@ ASM_END
                         return;
                         break;
                     case 3:
+#if BX_ROMBIOS32
                         set_e820_range(ES, regs.u.r16.di,
                                        0x00100000L,
                                        extended_memory_size - ACPI_DATA_SIZE, 1);
                         regs.u.r32.ebx = 4;
+#else
+                        set_e820_range(ES, regs.u.r16.di,
+                                       0x00100000L,
+                                       extended_memory_size, 1);
+                        regs.u.r32.ebx = 5;
+#endif
                         regs.u.r32.eax = 0x534D4150;
                         regs.u.r32.ecx = 0x14;
                         CLEAR_CF();
@@ -4969,7 +5172,7 @@ BX_DEBUG_INT74("int74_function: make_far
 int13_harddisk(EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
   Bit16u EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
 {
-  Bit32u lba;
+  Bit32u lba_low, lba_high;
   Bit16u ebda_seg=read_word(0x0040,0x000E);
   Bit16u cylinder, head, sector;
   Bit16u segment, offset;
@@ -5048,14 +5251,15 @@ int13_harddisk(EHAX, DS, ES, DI, SI, BP,
 
       // if needed, translate lchs to lba, and execute command
       if ( (nph != nlh) || (npspt != nlspt)) {
-        lba = ((((Bit32u)cylinder * (Bit32u)nlh) + (Bit32u)head) * (Bit32u)nlspt) + (Bit32u)sector - 1;
+        lba_low = ((((Bit32u)cylinder * (Bit32u)nlh) + (Bit32u)head) * (Bit32u)nlspt) + (Bit32u)sector - 1;
+        lba_high = 0;
         sector = 0; // this forces the command to be lba
         }
 
       if ( GET_AH() == 0x02 )
-        status=ata_cmd_data_in(device, ATA_CMD_READ_SECTORS, count, cylinder, head, sector, lba, segment, offset);
+        status=ata_cmd_data_in(device, ATA_CMD_READ_SECTORS, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
       else
-        status=ata_cmd_data_out(device, ATA_CMD_WRITE_SECTORS, count, cylinder, head, sector, lba, segment, offset);
+        status=ata_cmd_data_out(device, ATA_CMD_WRITE_SECTORS, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
 
       // Set nb of sector transferred
       SET_AL(read_word(ebda_seg, &EbdaData->ata.trsfsectors));
@@ -5117,9 +5321,9 @@ int13_harddisk(EHAX, DS, ES, DI, SI, BP,
       nlspt = read_word(ebda_seg, &EbdaData->ata.devices[device].lchs.spt);
 
       // Compute sector count seen by int13
-      lba = (Bit32u)(nlc - 1) * (Bit32u)nlh * (Bit32u)nlspt;
-      CX = lba >> 16;
-      DX = lba & 0xffff;
+      lba_low = (Bit32u)(nlc - 1) * (Bit32u)nlh * (Bit32u)nlspt;
+      CX = lba_low >> 16;
+      DX = lba_low & 0xffff;
 
       SET_AH(3);  // hard disk accessible
       goto int13_success_noah;
@@ -5141,16 +5345,17 @@ int13_harddisk(EHAX, DS, ES, DI, SI, BP,
       segment=read_word(DS, SI+(Bit16u)&Int13Ext->segment);
       offset=read_word(DS, SI+(Bit16u)&Int13Ext->offset);
 
-      // Can't use 64 bits lba
-      lba=read_dword(DS, SI+(Bit16u)&Int13Ext->lba2);
-      if (lba != 0L) {
-        BX_PANIC("int13_harddisk: function %02x. Can't use 64bits lba\n",GET_AH());
+      // Get 32 msb lba and check
+      lba_high=read_dword(DS, SI+(Bit16u)&Int13Ext->lba2);
+      if (lba_high > read_dword(ebda_seg, &EbdaData->ata.devices[device].sectors_high) ) {
+        BX_INFO("int13_harddisk: function %02x. LBA out of range\n",GET_AH());
         goto int13_fail;
         }
 
-      // Get 32 bits lba and check
-      lba=read_dword(DS, SI+(Bit16u)&Int13Ext->lba1);
-      if (lba >= read_dword(ebda_seg, &EbdaData->ata.devices[device].sectors) ) {
+      // Get 32 lsb lba and check
+      lba_low=read_dword(DS, SI+(Bit16u)&Int13Ext->lba1);
+      if (lba_high == read_dword(ebda_seg, &EbdaData->ata.devices[device].sectors_high)
+          && lba_low >= read_dword(ebda_seg, &EbdaData->ata.devices[device].sectors_low) ) {
         BX_INFO("int13_harddisk: function %02x. LBA out of range\n",GET_AH());
         goto int13_fail;
         }
@@ -5161,9 +5366,9 @@ int13_harddisk(EHAX, DS, ES, DI, SI, BP,
 
       // Execute the command
       if ( GET_AH() == 0x42 )
-        status=ata_cmd_data_in(device, ATA_CMD_READ_SECTORS, count, 0, 0, 0, lba, segment, offset);
+        status=ata_cmd_data_in(device, ATA_CMD_READ_SECTORS, count, 0, 0, 0, lba_low, lba_high, segment, offset);
       else
-        status=ata_cmd_data_out(device, ATA_CMD_WRITE_SECTORS, count, 0, 0, 0, lba, segment, offset);
+        status=ata_cmd_data_out(device, ATA_CMD_WRITE_SECTORS, count, 0, 0, 0, lba_low, lba_high, segment, offset);
 
       count=read_word(ebda_seg, &EbdaData->ata.trsfsectors);
       write_word(DS, SI+(Bit16u)&Int13Ext->count, count);
@@ -5201,11 +5406,12 @@ int13_harddisk(EHAX, DS, ES, DI, SI, BP,
         npc     = read_word(ebda_seg, &EbdaData->ata.devices[device].pchs.cylinders);
         nph     = read_word(ebda_seg, &EbdaData->ata.devices[device].pchs.heads);
         npspt   = read_word(ebda_seg, &EbdaData->ata.devices[device].pchs.spt);
-        lba     = read_dword(ebda_seg, &EbdaData->ata.devices[device].sectors);
+        lba_low = read_dword(ebda_seg, &EbdaData->ata.devices[device].sectors_low);
+        lba_high = read_dword(ebda_seg, &EbdaData->ata.devices[device].sectors_high);
         blksize = read_word(ebda_seg, &EbdaData->ata.devices[device].blksize);
 
         write_word(DS, SI+(Bit16u)&Int13DPT->size, 0x1a);
-        if ((lba/npspt)/nph > 0x3fff)
+        if (lba_high || (lba_low/npspt)/nph > 0x3fff)
         {
           write_word(DS, SI+(Bit16u)&Int13DPT->infos, 0x00); // geometry is invalid
           write_dword(DS, SI+(Bit16u)&Int13DPT->cylinders, 0x3fff);
@@ -5217,8 +5423,8 @@ int13_harddisk(EHAX, DS, ES, DI, SI, BP,
         }
         write_dword(DS, SI+(Bit16u)&Int13DPT->heads, (Bit32u)nph);
         write_dword(DS, SI+(Bit16u)&Int13DPT->spt, (Bit32u)npspt);
-        write_dword(DS, SI+(Bit16u)&Int13DPT->sector_count1, lba);  // FIXME should be Bit64
-        write_dword(DS, SI+(Bit16u)&Int13DPT->sector_count2, 0L);
+        write_dword(DS, SI+(Bit16u)&Int13DPT->sector_count1, lba_low);
+        write_dword(DS, SI+(Bit16u)&Int13DPT->sector_count2, lba_high);
         write_word(DS, SI+(Bit16u)&Int13DPT->blksize, blksize);
         }
 
@@ -6604,7 +6810,7 @@ get_hd_geometry(drive, hd_cylinders, hd_
     hd_type = inb_cmos(0x12) & 0x0f;
     if (hd_type != 0x0f)
       BX_INFO(panic_msg_reg12h,1);
-    hd_type = inb_cmos(0x1a); // HD0: extended type
+    hd_type = inb_cmos(0x1a); // HD1: extended type
     if (hd_type != 47)
       BX_INFO(panic_msg_reg19h,0,0x1a);
     iobase = 0x24;
@@ -7737,6 +7943,7 @@ Bit16u seq_nr;
   Bit16u bootseg;
   Bit16u bootip;
   Bit16u status;
+  Bit16u bootfirst;
 
   ipl_entry_t e;
 
@@ -7764,7 +7971,16 @@ Bit16u seq_nr;
   bootdev |= ((inb_cmos(0x38) & 0xf0) << 4);
   bootdev >>= 4 * seq_nr;
   bootdev &= 0xf;
-  if (bootdev == 0) BX_PANIC("No bootable device.\n");
+
+  /* Read user selected device */
+  bootfirst = read_word(IPL_SEG, IPL_BOOTFIRST_OFFSET);
+  if (bootfirst != 0xFFFF) {
+    bootdev = bootfirst;
+    /* User selected device not set */
+    write_word(IPL_SEG, IPL_BOOTFIRST_OFFSET, 0xFFFF);
+    /* Reset boot sequence */
+    write_word(IPL_SEG, IPL_SEQUENCE_OFFSET, 0xFFFF);
+  } else if (bootdev == 0) BX_PANIC("No bootable device.\n");
 
   /* Translate from CMOS runes to an IPL table offset by subtracting 1 */
   bootdev -= 1;
@@ -7785,7 +8001,7 @@ Bit16u seq_nr;
 
   /* Do the loading, and set up vector as a far pointer to the boot
    * address, and bootdrv as the boot drive */
-  print_boot_device(e.type);
+  print_boot_device(&e);
 
   switch(e.type) {
   case IPL_TYPE_FLOPPY: /* FDD */
@@ -9405,10 +9621,10 @@ pci_routing_table_structure:
   db 0x08 ;; PCI interrupt router DevFunc
   dw 0x0000 ;; PCI exclusive IRQs
   dw 0x8086 ;; compatible PCI interrupt router vendor ID
-  dw 0x7000 ;; compatible PCI interrupt router device ID
+  dw 0x122e ;; compatible PCI interrupt router device ID
   dw 0,0 ;; Miniport data
   db 0,0,0,0,0,0,0,0,0,0,0 ;; reserved
-  db 0x07 ;; checksum
+  db 0x37 ;; checksum
 pci_routing_table_structure_start:
   ;; first slot entry PCI-to-ISA (embedded)
   db 0 ;; pci bus number
@@ -9710,7 +9926,7 @@ pci_init_end:
   pop  bp
   pop  ds
   ret
-#endif // BX_ROMBIOS32
+#endif // !BX_ROMBIOS32
 #endif // BX_PCIBIOS
 
 #if BX_ROMBIOS32
@@ -9830,7 +10046,7 @@ rombios32_gdt:
   dw 0xffff, 0, 0x9300, 0x00cf ; 32 bit flat data segment (0x18)
   dw 0xffff, 0, 0x9b0f, 0x0000 ; 16 bit code segment base=0xf0000 limit=0xffff
   dw 0xffff, 0, 0x9300, 0x0000 ; 16 bit data segment base=0x0 limit=0xffff
-#endif
+#endif // BX_ROMBIOS32
 
 
 ; parallel port detection: base address in DX, index in BX, timeout in CL
@@ -9924,8 +10140,8 @@ rom_scan:
   ;;   2         ROM length in 512-byte blocks
   ;;   3         ROM initialization entry point (FAR CALL)
 
-  mov  cx, #0xc000
 rom_scan_loop:
+  push ax       ;; Save AX
   mov  ds, cx
   mov  ax, #0x0004 ;; start with increment of 4 (512-byte) blocks = 2k
   cmp [0], #0xAA55 ;; look for signature
@@ -10006,7 +10222,8 @@ rom_scan_increment:
   shl  ax, #5   ;; convert 512-bytes blocks to 16-byte increments
                 ;; because the segment selector is shifted left 4 bits.
   add  cx, ax
-  cmp  cx, #0xe000
+  pop  ax       ;; Restore AX
+  cmp  cx, ax
   jbe  rom_scan_loop
 
   xor  ax, ax   ;; Restore DS back to 0000:
@@ -10028,7 +10245,6 @@ bios_table_area_start:
 ;- POST -
 ;--------
 .org 0xe05b ; POST Entry Point
-bios_table_area_end:
 post:
 
   xor ax, ax
@@ -10290,6 +10506,12 @@ post_default_ints:
 #endif
   out  0xa1, AL ;slave  pic: unmask IRQ 12, 13, 14
 
+  mov  cx, #0xc000  ;; init vga bios
+  mov  ax, #0xc780
+  call rom_scan
+
+  call _print_bios_banner
+
 #if BX_ROMBIOS32
   call rombios32_init
 #else
@@ -10299,12 +10521,6 @@ post_default_ints:
 #endif //BX_PCIBIOS
 #endif
 
-  call _init_boot_vectors
-
-  call rom_scan
-
-  call _print_bios_banner
-
   ;;
   ;; Floppy setup
   ;;
@@ -10340,10 +10556,19 @@ post_default_ints:
   ;;
 #endif // BX_ELTORITO_BOOT
 
+  call _init_boot_vectors
+
+  mov  cx, #0xc800  ;; init option roms
+  mov  ax, #0xe000
+  call rom_scan
+
+#if BX_ELTORITO_BOOT
+  call _interactive_bootkey
+#endif // BX_ELTORITO_BOOT
+
   sti        ;; enable interrupts
   int  #0x19
 
-
 .org 0xe2c3 ; NMI Handler Entry Point
 nmi:
   ;; FIXME the NMI handler should not panic
@@ -11080,5 +11305,6 @@ static Bit8u vgafont8[128*8]=
 
 ASM_START
 .org 0xcc00
+bios_table_area_end:
 // bcc-generated data will be placed here
 ASM_END
Index: b/bios/rombios.h
===================================================================
--- a/bios/rombios.h	2007-02-20 11:36:55.000000000 +0200
+++ b/bios/rombios.h	2008-05-29 05:01:49.000000000 +0300
@@ -1,5 +1,5 @@
 /////////////////////////////////////////////////////////////////////////
-// $Id: rombios.h,v 1.4 2007/02/20 09:36:55 vruppert Exp $
+// $Id: rombios.h,v 1.6 2008/01/26 09:15:27 sshwarts Exp $
 /////////////////////////////////////////////////////////////////////////
 //
 //  Copyright (C) 2006 Volker Ruppert
@@ -57,3 +57,12 @@
 #define PM_IO_BASE        0xb000
 #define SMB_IO_BASE       0xb100
 #define CPU_COUNT_ADDR    0xf000
+
+  // Define the application NAME
+#if defined(BX_QEMU)
+#  define BX_APPNAME "QEMU"
+#elif defined(PLEX86)
+#  define BX_APPNAME "Plex86"
+#else
+#  define BX_APPNAME "Bochs"
+#endif
